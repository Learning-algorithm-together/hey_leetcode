package datastruct

import "fmt"

/**
1. 桶排序：顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，
每个桶里的数据再单独进行排序。
桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

外部排序：就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。
桶排序比较适合用在外部排序
*/
/**
比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，
但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？
*/
/**
我们可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 10 万元。
我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，
第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件，
并且按照金额范围的大小顺序编号命名（00，01，02…99）。

理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，
那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，
用快排来排序。等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，
并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。不过，你可能也发现了，
订单按照金额在 1 元到 10 万元之间并不一定是均匀分布的 ，所以 10GB 订单数据是无法均匀地被划分到 100 个文件中的。

有可能某个金额区间的数据特别多，划分之后对应的文件就会很大，没法一次性读入内存。这又该怎么办呢？
针对这些划分之后还是比较大的文件，我们可以继续划分，比如，订单金额在 1 元到 1000 元之间的比较多，
我们就将这个区间继续划分为 10 个小区间，1 元到 100 元，101 元到 200 元，201 元到 300 元…901 元到 1000 元。
如果划分之后，101 元到 200 元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。
*/
func bucketDemo() {

}

func bucketSort() {

}

/**
2. 计数排序，稳定
计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。
每个桶内的数据值都是相同的，省掉了桶内排序的时间。

假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A[8]中，它们分别是：2，5，3，0，2，3，0，3。

考生的成绩从 0 到 5 分，我们使用大小为 6 的数组 C[6]表示桶，其中下标对应分数。不过，C[6]内存储的并不是考生，而是对应的考生个数。
像我刚刚举的那个例子，我们只需要遍历一遍考生分数，就可以得到 C[6]的值。

我们从后到前依次扫描数组 A。比如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，
也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。
当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3]要减 1，变成 6。

以此类推，当我们扫描到第 2 个分数为 3 的考生的时候，就会把它放入数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。
当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的了。
*/

func countingDemo() {
	a := []int{2, 5, 3, 0, 2, 3, 0, 3}
	countingSort(a, len(a))
	fmt.Printf("a:%v \n", a)

}

func countingSort(a []int, n int) {
	//获取最大值
	//创建和最大值一致的数组。c
	//将a中的数计数，比如0将有两个所以c[0]=2
	//将c数组每个位置的值，都累加为前面的。
	//创建和a相同长度的临时数组tmp，
	//将c中的数按照计数法，放入tmp中
	//返回tmp，或者，复制给a
	fmt.Printf("a:%v \n", a)

	if n <= 1 {
		return
	}
	max := a[0]
	for _, v := range a {
		if max <= v {
			max = v
		}
	}

	c := make([]int, max+1) //0～max
	for _, v := range a {
		c[v]++
	}
	fmt.Printf("c1:%v \n", c)
	for i := range c {
		if i == 0 {
			continue
		}
		c[i] = c[i-1] + c[i]
	}
	fmt.Printf("c2:%v \n", c)
	tmp := make([]int, n)
	for _, v := range a {
		c[v]--
		tmp[c[v]] = v
	}
	for i, v := range tmp {
		a[i] = v
	}

	return
}

/**
3. 基数排序，稳定
1.假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？

我们之前讲的快排，时间复杂度可以做到 O(nlogn)，还有更高效的排序算法吗？桶排序、计数排序能派上用场吗？手机号码有 11 位，范围太大，
显然不适合用这两种排序算法。针对这个排序问题，有没有时间复杂度是 O(n) 的算法呢？现在我就来介绍一种新的排序算法，基数排序。

我们这里也可以借助相同的处理思路，先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，
以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。

2.排列字母，看基数排序图
这里按照每位来排序的排序算法要是稳定的，否则这个实现思路就是不正确的。
因为如果是非稳定排序算法，那最后一次排序只会考虑最高位的大小顺序，
完全不管其他位的大小关系，那么低位的排序就完全没有意义了。

如果有的数位数不够，可以末尾补0
*/

func redixDemo() {

}

func redixSort() {

}
